# In-depth HTTP and ReSTful API

## **Objective: -**

In this module we'll look at ...

- HTTP Servers
- Setting up an Echo Server
- Monitor and restart your server with nodemon
- HTTP Methods for CRUD operations
- Building a basic HTTP server with Node.js
- ReSTful API principles


<br>

---

<br>

## HTTP and RESTful APIs in more depth

Throughout the course, we've been working with API data and services from third parties like JSON Placeholder, `openweathermap.org`, and GitHub.

To do so, we've been leveraging the same request and response model used behind-the-scenes by browsers to fetch HTML, submit form data, and download files.

As we've seen before when working with `fetch` and `axios`, we can use JavaScript to leverage the same communication protocol used by the browser itself (called HTTP, or **H**yper **T**ext **T**ransfer **P**rotocol) to interact with API services that understand HTTP requests.

While HTTP is not the only way to interact with external services, it is by far the most common because of the browser's native support.

Now that we're building our own APIs to handle HTTP requests, let's take a closer look at what goes into an HTTP request and response.

<br>

---

## HTTP Servers

While working with file systems is very useful, Node's event-driven model and penchant for asynchronous programming mean that it really shines when used to serve content to thousands of requests at a time.

We often refer to the computers that listen to such requests "**servers**", and you'll often hear Node referred to as a _"server-side" JavaScript runtime_.

Because these hardware servers are rarely running anything other than a collection of applications to handle requests, those _applications_ are _also_ often called "_servers_" themselves.

The most common way for web applications (like the ones we've been building so far) to make requests of servers is through **HTTP**.

In our practice SPA, let's build our own application (or "service" or "server") to serve up content for web applications!

<br>

---

<br>

### Activity 1: Echo Server

[8.1.1-EchoServer.js](Activities/8.1-Activities/8.1.1-EchoServer.js)
In this activity we will create a basic `http` server _in our practice SPA_ that "echos" back a message sent in a request.

<br>

#### Testing Our Server

To run our server, we run the file just like any other JS file with `node <path or filename>`.

Unfortunately, every time we alter our file, we must stop the server with Ctrl+C and restart it with the same `node` command.

Luckily we will learn a better way to run and restart our server in the next lesson.

<br>

You could use `curl`, but there are other tools that you can often use on your local dev machine that serve similar purposes.

On the command line, take a look at [`httpie`](https://httpie.org/).

Better still, look at some GUI-based tools like [Postman](https://www.postman.com/) or [Insomnia](https://insomnia.rest/)

> We recommend Insomnia for its ease of use, and ability to do what we need in a simple manner.

<br>

## Setting up an Echo Server

### File Structure

1. Create a `server` folder inside your SPA. We will put all of our server files in this folder.
2. Inside `server`, create a file called `echo.js` where we will build our echo server.

<br>

### Build the server

1. Our server is created with a request listener callback function. This callback is invoked with two arguments: a `Request` Object and a `Response` Object (which describe the incoming HTTP request and outgoing response, respectively).

   ```js
   const server = http.createServer((request, response) => { }
   ```

2. `Request` Objects contain information about incoming requests, such as the headers associated with the request, the requested URL, and the body of the request itself. Because `Request` Objects are just Objects, we can log individual properties for inspection, e.g.:

   ```javascript
   const server = http.createServer((request, response) => {
     console.log(request.url); // logs the requested URL
   });
   ```

3. Most servers serve different content at different URLs. Let's start responding to different request URLs by creating an `if` block that will only respond if req.url === "/" (the root URL without a `pathname`)

   ```js
   const server = http.createServer((request, response) => {
     if (request.url === "/") {
     }
   });
   ```

4. Inside the `if` block there are several items we are going to set on the response Object.
   - The `response` has a `writeHead` method that can be used to write headers to the response. The writeHead method accepts a status code and options object. Every HTTP response needs to communicate what kind of `Content-Type` is going to be returned by the response. Most of the data that we'll send back and forth will be JSON, so let's set the `Content-Type` of all of our responses to `application/json`.
   - The `write` method writes a JavaScript Object to the root URL
   - `end` tells the server we are finished with this request/response cycle.

   ```javascript
       response.writeHead(200, { "Content-Type": "application/json" });
       response.write(JSON.stringify({ message: "Welcome to the main page" }));
       response.end();
   ```

5. Servers need to _listen_ for requests on a `port`. We've seen `parcel` use a `port` to serve our projects on `localhost`, and we can do the same here.
   -  Pick an unused port between 2000 and 9000 to listen for requests upon,
   -  then call your `server` Object's `listen` method with that `port`,
   -  and add a `log` after `listen` to let us know that the server is running:

   ```javascript
   server.listen(4040);
   console.log(`Listening on Port: ${4040}`);
   ```

<br>

---

<br>

## Monitor and restart your server with `nodemon`

As we start to make more changes to our server, it becomes increasingly cumbersome to remember to interrupt the running server process and restart the `node` command with every change.

We can automate that process of _watching_ source files for changes and _restarting_ the running process.

We can do so with an npm package called [**`nodemon`**](https://github.com/remy/nodemon#nodemon).

<br>

Let's set-up `nodemon` in our practice SPA:

1. Install `nodemon` as a `devDependency` with `npm install --save-dev nodemon`
2. Add a new `script` to `package.json`:

   ```json
   "watch": "nodemon --watch ./server -e js ./server/index.js"
   ```

   > **NOTE**: This serve script watches `./server/index.js`, where we will build our API server in the next lesson. To watch our echo server, change the file from `index.js` to `echo.js`.

<br>

3. Now, instead of running `node ./server/echo.js` in the terminal (and manually stopping and restarting our server), we can run `npm run watch`, and our server will automatically restart after every file change!

<br>

---

<br>

## HTTP Methods

By this point, we should be familiar with some aspects of GET and POST requests. But there are more HTTP verbs to explore! Let's take a look at some of these methods and how we might see them used in the wild.

<br>

When talking about HTTP methods, we further group those methods into **"safe"** methods and **"idempotent"** methods.

- **"Safe" methods** should not alter data. Generally speaking, `GET` is the only truly safe method.
- **"Idempotent" methods** should result in the same resource state no matter how many times the same request is made. IE. multiple identical requests will have the exact same outcomes. All of the methods except the `POST` and `PATCH` methods, should strive for idempotentcy.

<br>

| HTTP Method | Use-case                                      | Request Body \* | Response Body \* | Safe | Idempotent |
| ----------- | --------------------------------------------- | -------------- | --------------- | ---- | ---------- |
| **GET**     | Reading resources                             | empty          | not empty       | yes  | yes        |
| **POST**    | Often (but not always) creating new resources | not empty      | not empty       | no   | no         |
| **PUT**     | Creating or updating a specific resource      | not empty      | not empty       | no   | yes        |
| **PATCH**   | Updating a specific resource                  | not empty      | not empty       | no   | no \*\*     |
| **DELETE**  | Deleting a specific resource                  | empty          | not empty       | no   | yes        |

---

<br>

> \* Request and response bodies often follow these conventions, but there are a number of variations between implementations since adherence to these guidelines is entirely up to API authors. Some common variations might include `POST` or `PATCH` updates that only return a status code instead of returning a body that contains the new or edited resource, or `DELETE` requests that use a request body to identify the resource being deleted instead of using a URL.

<br>

> \*\* While PATCH requests are not _required_ to be idempotent, it's usually a good idea to make sure that your PATCH requests are idempotent anyway. There are some use-cases where a single PATCH depends on the current state of a resource, but it's often better to handle the calculation of that new state on the client instead of in the server.

<br>

This is not an exhaustive list of HTTP methods, but these are the ones you'll encounter most often, and the methods that map most cleanly to the "CRUD" operations we've seen so far in the course.

You can see an [exhaustive list of HTTP methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) in the Mozilla documentation

<br>

> **NOTE: On Idempotence ...**
>
> Idempotence is a funky word that often hooks people. Idempotentce is sometimes a confusing concept, at least from the academic definition.
>
> From a RESTful service standpoint, for an operation (or service call) to be idempotent, clients can make that same call repeatedly while producing the same result. In other words, making multiple identical requests has the same effect as making a single request.
>
> **Note that while idempotent operations produce the same result on the server (no side effects), the response itself may not be the same (e.g. a resource's state may change between requests).**
>
> The PUT and DELETE methods are defined to be idempotent. However, there is a caveat on DELETE. The problem with DELETE, which if successful would normally return a 200 (OK) or 204 (No Content), will often return a 404 (Not Found) on subsequent calls, unless the service is configured to "mark" resources for deletion without actually deleting them. However, when the service actually deletes the resource, the next call will not find the resource to delete it and return a 404. However, the state on the server is the same after each DELETE call, but the response is different.
>
> GET, HEAD, OPTIONS and TRACE methods are defined as safe, meaning they are only intended for retrieving data. This makes them idempotent as well since multiple, identical requests will behave the same.

<br>

---

<br>

## REST Principles

In previous lessons or in documentation that you've seen while exploring on your own, you'll probably have heard APIs described as "ReSTful".

Unlike HTTP, REST (or **Re**sponsive **S**tate **T**ransfer) is not a protocol or specification; rather, _REST is an architectural pattern_.

It is not the only way to build APIs, nor is it necessarily coupled to HTTP as a means of transferring state responsively, but we'll find that the principles of a ReSTful architecture map intuitively to the HTTP protocol that we've been using thus far. And we will find that the API we just built is, in fact, a ReSTful API!

<br>

**ReSTful applications are built around 5 core values:**

1. Client-Server Separation
2. Statelessness
3. Cacheable Resources
4. Uniform Interface
5. Layered Architecture

<br>

> Note that nowhere do these values mention specific protocols like HTTP, or data formats like JSON. But let's look at why it's so common to find ReSTful APIs that use HTTP to expose data as JSON:

<br>

### **Client-Server Separation, Statelessness, and Cacheable Resources**

These requirements are met simply by using HTTP.

- As we've already discovered, HTTP forces servers to handle generic requests that might come from any number of clients, which also enforces a general **client-server separation**.
- Additionally, HTTP requests and responses can only contain headers and bodies; all state must be included in one of those places, in every request and every response, which satisfies the **statelessness requests**.
- And finally, the consistent format of HTTP requests means that **any request or response could be stored (or "cached")** without requiring a persistent connection to the underlying HTTP service.

<br>

### **Uniform Resources**

We've intuitively stumbled upon this principle in our existing API by leveraging HTTP methods:

Once you know that you can interact somehow with a "user" resource, then you can surmise that ...

- `GET /users` would get you the entire collection of users,
- `GET /users/:id` would get you a single user,
- `POST /users` would create a new user,
- `PATCH /users/:id` would edit a user if it exists,
- `DELETE /users/:id` would delete a user if it exists, and
- `PUT /users/:id` would create a new user with a specific `id` if it didn't already exist, and update that user if it existed before.

You can apply that same logic to any resource that we might want to create in the future, from "author" to "reader" and so on and so forth.

That consistent pattern of accessing resources through a Unique Resource Identifier (or URI, also known as a URL) gives ReSTful APIs a discoverability missing from APIs designed without such constraints.

<br>

### **Layered Architecture**

And finally, we've found that the use of **HTTP + JSON + Node + a format-agnostic data store**, has given us an architecture that can be interchange-able at the interfaces:

- We could exchange our MongoDb database for FireStore or PostgreSQL at any time, and the user consuming JSON from our API would never know. (You could read more about Google FireStore or PostgreSQL in the [Curriculum Addendum Section](../AddendumOfResources/AddendumOfResources.md))
- We could switch from Node to Deno, or from Python to Ruby, or to a compiled Go or Rust binary and, **as long as the HTTP service contract was maintained**, the user would never know.

<br>

### So, since our API meets all of the above specifications, congratulate yourself! You've now written your first RESTful API!

<br>

---

<br>

### **Summary: -**

In this module we learned ...

- HTTP and ReSTful APIs in more depth
- How to implement HTTP Methods for CRUD operations
- How to build a basic HTTP server with Node.js
- The 5 principles of ReSTful APIs
- HTTP Servers and how to Setup an simple Node Echo Server
- Monitoring and auto-restart your server with `nodemon`
