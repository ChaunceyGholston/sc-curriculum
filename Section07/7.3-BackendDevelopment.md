# Introduction to Backend Development

## **Objective: -**

In this module we'll look at ...

- 3 Tier Application Architecture
- Backend Development and Databases
- SQL & Relational Database Management Systems
- NoSQL & Document Databases
- **ACID** and **CRUD** Database Features
- Node.js and JavaScript Outside the Browser
- Node vs Browser JavaScript
- Modules in CommonJS vs ES6
- Built-in Node Modules

<br>

---

<br>

## 3 Tier Application Architecture

The 3 Tier Application Architecture is made up of 3 portions as follows:

![3 Tier Application Architecture Diagram](img/3TierArchitecture.png)

- Presentation Tier:
  - Presents the user with an interface to interact
  - Stores session data and makes requests and handles responses to/from the application tier
  - Written or transcoded to JavaScript
  - This is considered Frontend Development
- Application Tier:
  - Handles communication between presentation and data layers
  - Establishes business requirements such as authentication, authorization and validation
  - Can be written in any number of server side programming languages including Python, Java and now JavaScript.
  - This is considered Backend Development
- Data Tier:
  - Persists the data for the application tier.
  - The presentation and data tiers should never communicate directly.
  - Typical an SQL or NoSQL database server
  - The Data Tier could be the responsibility of developers, DevOps, or DBAs (Database Administrators) depending on the organization

<br>

---

<br>

## What is Backend Development

Backend refers to the server side of the website; it is the portion of software that does not come in direct contact with the users. It stores and arranges data, and also makes sure everything on the client-side of the website works fine.

<br>

### **Databases**

A dynamic site requires a database to work properly. All information is stored in the database, like user profiles or images they've uploaded, or blog posts. Web developers work with programming languages like Java or .Net Framework, since they need to work with something the database understands. The code they write communicates with the server and then tells the browser what to use from the database.

<br>

---

<br>

## SQL & Relational Database Management Systems

<br>

**SQL** (**S**tructured **Q**uery **L**anguage) is a standard language for accessing and manipulating _relational_ databases. Although SQL is a standard, there are different versions of the SQL language. However, to be compliant with the standard, they all support at least the major commands (such as `SELECT`, `UPDATE`, `DELETE`, `INSERT`, `WHERE`) in a similar manner. Most of the SQL database programs also have their own proprietary extensions in addition to the SQL standard.

The data in **R**elational **D**atabase **M**anagement **S**ystem (**RDBMS**) is stored in database objects called _tables_. A table is a collection of related data entries and it consists of _columns_ and _rows_. A _record_, also called a row, is each individual entry that exists in a table. A record is a horizontal entity in a table. A _column_ is a vertical entity in a table that contains all information associated with a specific field in a table.

Relational databases require that schemas be defined before you can add data. For example, you might want to store data about your customers such as phone numbers, first and last name, address, city and state – a SQL database needs to know what you are storing in advance.

<br>

---

<br>

## NoSQL & Document Databases

<br>

A **NoSQL** (originally referring to "**no**n **SQL**" or "_non relational_") database provides a mechanism for storage and retrieval of data that is modeled in means _other_ than the tabular relations used in relational databases. NoSQL systems are also sometimes called "**N**ot **o**nly **SQL**" to emphasize that they may support SQL-like query languages or sit alongside SQL databases.

In a _**relational database**_, a book record is often dissembled (or “normalized”) and stored in _separate tables_, and relationships are defined by _primary_ and _foreign keys_. For example, a Books table could have columns for ISBN, Book Title, and Edition Number, while the Authors table has columns for AuthorID and Author Name, and finally the Author-ISBN table has columns for AuthorID and ISBN. The relational model is designed to enable the database to enforce referential integrity between tables in the database, normalized to reduce the redundancy, and generally optimized for storage.

In a _**NoSQL database**_, a book record is usually stored as a JSON document. For each book, the item, ISBN, Book Title, Edition Number, Author Name, and AuthorID are stored as attributes in a single document. In this model, data is optimized for intuitive development and horizontal scalability.

<br>

### NoSQL Database Types

- _**Document** databases_ pair each key with a JSON-like complex data structure known as a document. Documents can contain many different key-value pairs, or key-array pairs, or even nested documents.
- _**Graph** stores_ are used to store information about _networks_ of data, such as social connections. Graph stores include Neo4J and Giraph.
- _**Key-value stores**_ are the simplest NoSQL databases. Every single item in the database is stored as an attribute name (or 'key'), together with its value. Examples of key-value stores are Riak and Berkeley DB. Some key-value stores, such as Redis, allow each value to have a type, such as 'integer', which adds functionality.
- _**Wide-column stores**_ such as Cassandra and HBase are optimized for queries over large datasets, and store columns of data together, instead of rows

<br>

---

<br>

## Database Features

<br>

### **ACID**

In database systems, **ACID (Atomicity, Consistency, Isolation, Durability)** refers to a standard set of properties that guarantee database transactions are processed reliably. ACID is especially concerned with how a database recovers from any failure that might occur while processing a transaction. An ACID-compliant DBMS ensures that the data in the database remains accurate and consistent despite any such failures.

- **Atomicity** - Atomicity means that you guarantee that either all of the transaction succeeds or none of it does. You don’t get part of it succeeding and part of it not. If one part of the transaction fails, the whole transaction fails. With atomicity, it’s either “all or nothing”.
- **Consistency** - This ensures that you guarantee that all data will be consistent. All data will be valid according to all defined rules, including any constraints, cascades, and triggers that have been applied on the database.
- **Isolation** - Guarantees that all transactions will occur in isolation. No transaction will be affected by any other transaction. So a transaction cannot read data from any other transaction that has not yet completed.
- **Durability** - Durability means that, once a transaction is committed, it will remain in the system – even if there’s a system crash immediately following the transaction. Any changes from the transaction must be stored permanently. If the system tells the user that the transaction has succeeded, the transaction must have, in fact, succeeded.

All of the major RDBMS adhere to the ACID principles. They all include features that ensure that the data maintains consistent throughout software and hardware crashes, as well as any failed transactions.

<br>

NoSQL databases are a bit different. NoSQL databases are often designed to ensure high availability across a cluster, which usually means that consistency and/or durability is sacrificed to some degree.

Most NoSQL DBMSs can provide atomicity to some degree. Most NoSQL DBMS work on a eventually consistent basis, meaning that, data may be out of sync for a time, but it will eventually be in sync.

Some vendors, such as MarkLogic, OrientDB, and Neo4j offer ACID compliant NoSQL database management systems.

<br>

### **CRUD**

Databases provide four basic types of functionality. The database must be able to **C**reate, **R**ead, **U**pdate, and **D**elete resources (**CRUD**).

- **Create** - new entry in collection/table
- **Read** - retrieve the resource and display the results
- **Update** - changes information in an entry
- **Delete** - remove the entry

<br>

---

<br>

So far, we've been using JavaScript in the browser to give our users richer experiences in the web.

But the JavaScript _language_ that we've been using in these browsers needs additional code to manage all of the housekeeping tasks that make JavaScript so simple to work with (like memory management, eventing, and optimization).

That additional code is called a **runtime**, and every browser includes some kind of JavaScript-specific runtime.

In addition to that runtime, browsers expose some of their functionality to the JavaScript runtime through many of the browser-specific Objects and APIs that we've already encountered (like the global `window` object and the DOM).

<br>

## Node.js

But those browser-specific helpers are not an intrinsic part of either JavaScript-the-_language_ or the _runtimes_ that power that language.

One might imagine, then, that the JavaScript runtimes that we've been using up to this point might be able to be separated entirely from the browser and run as their own process, giving JavaScript the power to run _anywhere_!

This is exactly what happened with the development of the browser-less JavaScript runtime called Node.js.

Today, Node.js is used from satellites, to servers, to command-lines, to text editors!

As you might recall from the very first class, we've been using many of these tools from the beginning: `npm`, `parcel`, `eslint` and even VS Code are written in JavaScript as Node applications.

<br>

---

<br>

## Node vs Browser JavaScript

### REPL

We've extensively used the REPL in Chrome's console tab to try out functions or debug existing applications. Node.js _also_ includes a REPL, accessible in your terminal with the command `node`.

Unlike the browser's REPL, `node` doesn't give us access to auto-suggestions or return previews. To exit Node's REPL, use `CTRL + D` or type `.exit`

<br>

### Global Object

While JavaScript-the-language is mostly the same between Node and evergreen browsers, one of the biggest difference between the two platforms is the name of the global object. We know that in the browser the global object is `window`, but in Node the global object is `global`

<br>

---

<br>

### Activity 1: Explore `global`

1. Run [7.3.1-Evr-Global.js](Activities/7.3-Activities/7.3.1-Evr-Global.js) in the terminal
2. Notice that we still have access to many of the global timer methods from the browser (i.e. `setTimeout` and `setInterval`), but most of the rest of the `window` is missing.

<br>

---

<br>

## Modules: CommonJS vs ES6

Module syntax is another major difference between JS in the Node and browser.
By default, Node.js uses CommonJS module syntax. This module system predates the `import`/`export` statements we've been using for browser modules so far, but maps well to our current understanding of modules:

| Browsers (ES6 modules)                   | Node (CommonJS)                                                |
| ---------------------------------------- | -------------------------------------------------------------- |
| `import DefaultThing from 'some-module'` | `const DefaultThing = require('some-module')`                  |
| `import { Thing } from 'some-module'`    | `const { DefaultThing } = require('some-module')`              |
| `export default DefaultThing`            | `module.exports = DefaultThing`                                |
| `export Thing`                           | `module.exports = { Thing }` or `module.exports.Thing = Thing` |

<br>

Notice that CommonJS modules are imported with a globally-availabe `require()` function, and are exported through the `exports` property of a module-level Object called `module`.

<br>

---

<br>

### Activity 2: Examine CommonJS modules

1. Examine [mathUtilities.js](Activities/7.3-Activities/mathUtilities.js) and note the CommonJS export syntax
2. Examine [7.3.2-Evr-CommonJSModules.js](Activities/7.3-Activities/7.3.2-Evr-CommonJSModules.js) and note the use of `require()` to import
3. Run [7.3.2-Evr-CommonJSModules.js](Activities/7.3-Activities/7.3.2-Evr-CommonJSModules.js) to see the result of our module.

<br>

---

<br>

## Built-in Modules

Node.js contains a number of built-in modules that you can `require` and use in your code. There are different modules that you can bring in depending on what goal you're trying to accomplish.

Here are a few:

- `path`: provides utilities for working with **file and directory paths**; helps normalize paths, determine file extensions, and return specific parts of a file path
- `crypto`: provides utilities for **cryptographic functionality**; useful for creating hashes or working with private/public key infrastructure
- `fs`: provides utilities for interacting with the **file system**; how we create, read, update, and delete files from the computer
- `http`: used to create and handle HTTP requests and responses

> You can learn more about the different built-in modules in the [Node.js documentation](https://nodejs.org/api/)

<br>

---

<br>

### Activity 3: File Manipulation with `fs`

[3-Evr-FileManipulation.js](Activities/7.3-Activities/3-Evr-FileManipulation.js)
In this activity, we will synchronously create a new temporary directory and file, read the file, and then delete the temp directory.

<br>

> **NOTE**: In general, Node's built-in modules will provide three different "flavors" of functions that you can use to accomplish the same task
>
> 1.  **`*Sync` (or synchronous)**: the event loop that manages tasks for your Node process (much like in the browser) will completely stop execution until the function finishes its task. These functions make control flow easy to reason about, but _should be avoided when working with operations that will block the main thread for long amounts of time_.
>
> 2.  **callback-based**: these functions are **asynchronous**, which means that we can assign some work to be executed whenever the function completes without blocking the entire Node process. This assignment is done through a _callback_ function, much like we've seen when working with Events in the browser. Before we had asynchronous primitives in JavaScript (i.e. `Promise`), callbacks were the preferred method of working with long-running tasks (like interacting with a file system). As the complexity of those asynchronous tasks increases, though, callback functions require deeper and deeper nesting, resulting in "callback hell" or "triangles of doom".
>
> 3.  **`Promise`-based**: these functions are _asynchronous_, but return `Promise`-es that can be handled with `.then()` and `.catch()`. The `Promise`-based workflow is generally easier to read and reason about than nested callbacks while avoiding the performance pitfalls of the synchronous versions when many long-running tasks must be handled at the same time. But Promises incur their own overhead, meaning that the Promise-based methods are _best suited to handling complex codebases or situations where the synchronous methods would block the main thread for too long_.

<br>

---

<br>

### **Summary: -**

In this module we looked at ...

- 3 Tier Application Architecture
- Backend Development and Databases
- SQL & Relational Database Management Systems where the data is stored in database objects called tables
- Types of NoSQL & Document Databases which are also sometimes called "**N**ot **O**nly **SQL**" to emphasize that they may support SQL-like query languages or sit alongside SQL databases
- The **ACID** database feature explains standards that guarantee DB transactions are processed reliably
- The DB **CRUD** features explaining the four basic types of transactional functionality
- Node.js and JavaScript Outside the Browser
- Node vs Browser JavaScript, the Node REPL, and the Global Object
- Modules in Node/CommonJS vs ES6 in browsers, and built-in Node.js modules

